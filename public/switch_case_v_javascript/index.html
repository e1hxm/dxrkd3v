<!DOCTYPE html>
<html lang="ru">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Switch / Case в JavaScript</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        MathJax = {
          tex: {
            inlineMath: [['\\(', '\\)']], 
            displayMath: [['\\[', '\\]']], 
          },
          options: {
            skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre'], 
          },
          svg: {
            fontCache: 'global' 
          }
        };
        </script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/remixicon/3.7.0/remixicon.css">
    <link
            rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/tokyo-night-dark.min.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>
        <script>
            hljs.highlightAll();
        </script>
        <script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12"></script>
    <link rel="stylesheet" href="/styles/style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">
</head>
<body>
    
     
    <a href="javascript:history.back()" class="back-button" id="back-button">
        <i class="ri-arrow-drop-left-line"></i>
    </a>
    
    <div class="nav__menu" id="nav-menu">
        <ul class="nav__list">
           <li class="nav__item">
              <a href="/" class="nav__link active-link">Home</a>
           </li>

           <li class="nav__item">
              <a href="/me/" class="nav__link">About</a>
           </li>

           <li class="nav__item">
              <a href="/links/" class="nav__link">Links</a>
           </li>

        </ul>

        
        <div class="nav__close" id="nav-close">
           <i class="ri-close-line"></i>
        </div> 
     </div>
     
     <div class="nav__toggle" id="nav-toggle">
        <i class="ri-menu-5-line"></i>
     </div>
    
    <div class="author">
        <a href="/">
        <img class="author-avatar" src="/images/ava.jpeg">
        </a>
    </div>
    <div class="clearfix">
    <div class="col12 md:col8 lg:col6 mxauto pl2 pr2">
    <div class="post">    
        <nav class="col11 mxauto">
    <div class="flex align-center justify-center">
        <a href="/" class="Logo no-underline h2 serif bold mb0">Dxrkd3v</a>
    </div>
    <div class="mt4 h5 text-center">
        <a href="/" class="gray no-underline inline-block mx2 mt1 md:mt0">Home</a>
        <a href="/me/" class="gray no-underline inline-block mx2 mt1 md:mt0">About</a>
        <a href="/links/" class="gray no-underline inline-block mx2 mt1 md:mt0">Links</a>
      </div>
</nav>
        
<div class="list">
   <div class="singleHead">
    <div class="sinleHeadTexts">
        
            <h2 class="title__center">Switch / Case в JavaScript</h2>
        

        
            <time class="h5 gray title__date">05 May 2024</time>
        

        <div><p>
                            Лекция про оператор Switch / Case в JavaScript c Udemy
                        </p>
                        <p>
                            Другие языки программирования, помимо условной конструкции if, 
                            поддерживают оператор switch. Это специализированная альтернатива if, 
                            предназначенная для определенных сценариев. 
                            Она полезна, когда необходима цепочка if else для проверки на равенство. Например:
                        </p>
                        <pre><code>if (status === 'processing') {
// Делаем раз
} else if (status === 'paid') {
// Делаем два
} else if (status === 'new') {
// Делаем три
} else {
// Делаем четыре
}</code></pre>
                        <p>
                            Одна из особенностей этой сложной проверки заключается в том, 
                            что каждая ветка зависит от значения переменной status. 
                            Оператор switch позволяет более кратко и выразительно записать этот код: 
                        </p>
                        <pre><code>switch (status) {
case 'processing': // status === 'processing' (строгое соответствие)
  // Делаем раз
  break;
case 'paid': // status === 'paid'
  // Делаем два
  break;
case 'new': // status === 'new'
  // Делаем три
  break;
default: // else
  // Делаем четыре
}</code></pre>
                        <p>
                            Оператор switch является сложной конструкцией из-за следующих компонентов:
                        </p>
                        <p>
                            1) Заголовок switch, который содержит ключевое слово switch и переменную, 
                            по которой будет осуществляться выбор поведения.
                        </p>
                        <p>
                            2) Фигурные скобки, в которых перечислены различные варианты выбора.
                        </p>
                        <p>
                            3) Конструкции case и default, в которых определяется 
                            поведение для разных значений переменной. 
                            Каждый case подобен условному оператору if, а default 
                            аналогичен ветке else. Указывать default необязательно, но рекомендуется для чистоты кода.
                        </p>
                        <p>
                            4) Использование оператора break предотвращает "проваливание" выполнения от одного case к другому без необходимости.
В итоге, оператор switch представляет собой мощный инструмент для выбора различных вариантов исполнения кода
                        </p>
                        <p>
                            В отличие от других конструкций, фигурные скобки в switch 
                            не определяют блок кода. Внутри них допускается использовать только синтаксис для case и default. 
                            Внутри каждого case (и default) 
                            разрешено выполнять произвольный код, открывая широкие возможности для логики программы
                        </p>
                        <pre><code>switch (count) {
case 1:
  // Делаем что-то полезное
  break;
case 2:
  // Делаем что-то полезное
  break;
default:
  // Что-то делаем
}</code></pre>
                        <p>
                            Иногда выполнение кода внутри блока case может 
                            привести к завершению функции, содержащей switch. 
                            В таком случае необходимо вернуть полученный результат наружу. 
                            Для этого можно воспользоваться двумя способами.
                        </p>
                        <p>
                            Подход первый: объявить переменную перед switch, 
                            заполнить её внутри блока case, а затем вернуть значение этой переменной в конце функции. 
                        </p>
                        <pre><code>(count) => {
// Объявляем переменную
let result;
// Заполняем
switch (count) {
  case 1:
    result = 'one';
    break;
  case 2:
    result = 'two';
    break;
  default:
    result = null;
}
// Возвращаем
return result;
};</code></pre>
                        <p>
                            Более простой и компактный подход заключается в том, 
                            что вместо создания переменной вы можете использовать оператор return внутри 
                            блока case для непосредственного возврата значения из функции. 
                            Поскольку после оператора return 
                            исполнение функции завершается, можно избавиться от использования оператора break: 
                        </p>
                        <pre><code>(count) => {
switch (count) {
  case 1:
    return 'one';
  case 2:
    return 'two';
  default:
    return null;
    }
};</code></pre>
                        <p>
                            Использование оператора switch в коде не является абсолютно необходимым 
                            с технической точки зрения, поскольку можно обойтись без него. 
                            Его главное преимущество заключается в том, что он позволяет программисту 
                            более явно выразить свои намерения при проверке конкретных значений переменной. 
                        </p>
<p>Хотя использование switch может привести к небольшому увеличению физического объема кода,
он делает его более читаемым и понятным, в отличие от цепочки блоков else if.</p>
</div>
    </div>
   </div>
</div>
 
        
<div class="mt4 h5 text-center">
    <a href="/" class="gray no-underline inline-block mx2 mt1 md:mt0">Home</a>
    <a href="/me/" class="gray no-underline inline-block mx2 mt1 md:mt0">About</a>
    <a href="/links/" class="gray no-underline inline-block mx2 mt1 md:mt0">Links</a>
    <br />
    <br />
    <a href="mailto:mail@dxrkd3v@ro.ru" class="gray no-underline inline-block mx2">
        Text me
    </a>
</div>
<br />
<br />

<a href="#" class="scrollup" id="scroll-up">
    <i class="ri-arrow-drop-up-line"></i>
 </a>


 
    </div>
    </div>
    </div>
    <script>
          

        document.addEventListener('DOMContentLoaded', () => {
    const backButton = document.getElementById('back-button');

    if (backButton) {
        
        if (window.location.pathname === '/' || window.location.pathname === '/index.html') {
            backButton.classList.add('hidden');
        } else {
            backButton.classList.remove('hidden');
        }
    }
});
        
let scrollUp = () =>{
	const scrollUp = document.getElementById('scroll-up')
	this.scrollY >= 350 ? scrollUp.classList.add('show-scroll')
						: scrollUp.classList.remove('show-scroll')
}
window.addEventListener('scroll', scrollUp)

const navMenu = document.getElementById('nav-menu'),
      navToggle = document.getElementById('nav-toggle'),
      navClose = document.getElementById('nav-close');

 
if (navToggle) {
    navToggle.addEventListener('click', () => {
        document.body.classList.add('show-menu');
    });
}

 
if (navClose) {
    navClose.addEventListener('click', () => {
        document.body.classList.remove('show-menu');
    });
}

 
document.addEventListener('click', (event) => {
    const isClickInsideMenu = navMenu.contains(event.target); 
    const isClickOnToggle = navToggle.contains(event.target); 

    
    if (!isClickInsideMenu && !isClickOnToggle && document.body.classList.contains('show-menu')) {
        document.body.classList.remove('show-menu');
    }
});

const navLinks = document.querySelectorAll('.nav__link');

const setActiveLink = () => {
    const currentPath = window.location.pathname;

    navLinks.forEach(link => {
        const linkPath = new URL(link.href).pathname;

        if (linkPath === currentPath) {
            link.classList.add('active-link');
        } else {
            link.classList.remove('active-link');
        }
    });
};

window.addEventListener('load', setActiveLink);

window.addEventListener('popstate', setActiveLink);

document.addEventListener('DOMContentLoaded', () => {
    const typedContainers = document.querySelectorAll('.typed-container');

    const observer = new IntersectionObserver((entries, obs) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const container = entry.target;
          const typedId = container.querySelector('span').id;
          const stringsEl = container.querySelectorAll('.typed-strings p');

          const strings = Array.from(stringsEl).map(el => el.textContent);

          new Typed(`#${typedId}`, {
            strings,
            typeSpeed: 75,
            backSpeed: 25,
            backDelay: 1500,
            startDelay: 300,
            loop: false,
            showCursor: true,
            cursorChar: '|'
          });

          obs.unobserve(container); 
        }
      });
    }, { threshold: 0.5 }); 

    typedContainers.forEach(container => observer.observe(container));
  });
    </script>
</body>
</html>