+++
date = '2025-03-15T11:00:24+03:00'
title = 'Как работают замыкания в JavaScript'
categories = [ "javascript" ]
+++

Замыкание в JavaScript — это концепция, при которой внутренняя функция имеет доступ к переменным своей внешней функции, даже если внешняя функция уже завершила выполнение. Это происходит благодаря тому, как JavaScript управляет областью видимости.

Когда функция создается, она захватывает все переменные из своей области видимости. Если внутренняя функция возвращается или используется за пределами своей родительской функции, она сохраняет ссылку на эти переменные. Таким образом, внутренний код функции «помнит» данные, которые были доступны в момент её создания, и продолжает работать с ними, даже если родительская функция завершила своё выполнение.

Простой механизм, лежащий в основе замыкания, заключается в том, что JavaScript создает объект, называемый лексическим окружением, который содержит ссылки на все переменные из области видимости внешней функции. Этот объект сохраняется, пока существует ссылка на внутреннюю функцию, и не уничтожается до тех пор, пока он не станет ненужным.

Код из прошлой лекции:

```js
function outer() {
    let count = 0;
    return function inner() {
        count++;
        console.log(count);
    };
}

const increment = outer();
increment(); // 1
increment(); // 2
```

В этом примере функция `inner` сохраняет ссылку на переменную `count`, которая определена в `outer`, даже после завершения выполнения `outer`.

А это уже пример кода с использованием замыкания для приватных данных:

```js
function createCounter() {
    let count = 0;
    return {
        increment() {
            count++;
            console.log(count);
        },
        decrement() {
            count--;
            console.log(count);
        }
    };
}

const counter = createCounter();
counter.increment(); // 1
counter.decrement(); // 0
```

Здесь `count` является «приватной» переменной, доступ к которой возможен только через функции `increment` и `decrement`. Внешний код не может напрямую изменять `count`, но эти функции могут манипулировать значением благодаря замыканию.

Асинхронное использование замыкания:

```js
function delayedMessage(message, delay) {
    setTimeout(function() {
        console.log(message);
    }, delay);
}

delayedMessage("Hello after 2 seconds", 2000);
```

В этом случае замыкание позволяет функции внутри `setTimeout` сохранить доступ к переменной `message`, даже несмотря на то, что выполнение откладывается.

Замыкания обеспечивают большую гибкость при работе с функциями в JavaScript. Они позволяют изолировать данные, создавать приватные переменные и эффективно работать с асинхронными задачами, сохраняя контекст их выполнения.